<!DOCTYPE html>
<html lang="en">

<head>
	<title>Controller | Solder Ninja</title>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<meta name="robots" content="noindex">
	<link rel="preconnect" href="https://fonts.googleapis.com">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link href="https://fonts.googleapis.com/css2?family=Bebas+Neue&display=swap" rel="stylesheet">
	<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
	<link href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.0/font/bootstrap-icons.css" rel="stylesheet">
	<script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
	<script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
	<script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
	<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
	<style>
		div.card {
			margin: 1rem;
		}

		.icon-pixel {
			width: 5px;
			height: 5px;
		}

		.navbar {
			background-color: #FCE477;
			box-shadow: 0 0.125rem 0.25rem rgba(0, 0, 0, 0.075);
			padding: 16px 0 8px;
		}

		.navbar .navbar-brand {
			color: #212529;
			font-family: "Bebas Neue", "Odoo Unicode Support Noto", sans-serif;
			font-size: 26.6667px;
			font-weight: 400;
			line-height: 40px;
			padding-bottom: 3.75px;
			padding-top: 3.75px;
		}

		.navbar .nav-link {
			color: rgba(0, 0, 0, 0.65);
			font-family: "Bebas Neue", "Odoo Unicode Support Noto", sans-serif;
			font-size: 1.3125rem;
		}

		.navbar .nav-link.active {
			color: rgb(0, 0, 0);
		}

		h1 {
			font-size: 3.875rem;
			color: #212529;
			font-family: "Bebas Neue", "Odoo Unicode Support Noto", sans-serif;
		}

		.card-header .nav-link {
			color: rgb(0, 0, 0);
		}
	</style>
</head>

<body>
	<!-- Bootstrap Header/Navbar -->
	<nav class="navbar navbar-expand-lg pt-3 shadow-sm">
		<div class="container flex-wrap">
			<div class="d-grid align-items-center w-100 pb-3">
				<a href="https://www.solder.ninja/" class="navbar-brand mx-auto mw-100"><span
						style="font-size: 1.9375rem;">Solder&nbsp;Ninja</span></a>
			</div>
			<div class="d-flex justify-content-center w-100">
				<ul role="menu" id="top_menu" class="nav navbar-nav top_menu pb-0">
					<li role="presentation" class="nav-item">
						<a role="menuitem" href="https://www.solder.ninja/" class="nav-link ">
							<span>Home</span>
						</a>
					</li>
					<li role="presentation" class="nav-item">
						<a role="menuitem" href="https://www.solder.ninja/pen" class="nav-link">
							<span>Pen</span>
						</a>
					</li>
					<li role="presentation" class="nav-item">
						<a role="menuitem" href="https://www.solder.ninja/tweezers" class="nav-link">
							<span>Tweezers</span>
						</a>
					</li>
					<li role="presentation" class="nav-item">
						<a role="menuitem" href="https://www.solder.ninja/station" class="nav-link">
							<span>Station</span>
						</a>
					</li>
					<li role="presentation" class="nav-item">
						<a role="menuitem" href="https://www.solder.ninja/blog/news-6" class="nav-link">
							<span>News</span>
						</a>
					</li>
					<li role="presentation" class="nav-item ">
						<a role="menuitem" href="https://sitronlabs.github.io/Solder-Ninja-Webapp/"
							class="nav-link active">
							<span>App</span>
						</a>
					</li>
				</ul>
			</div>
		</div>
	</nav>

	<div class="container py-5">
		<h1 style="text-align: center;">Solder Ninja Webapp</h1>
	</div>

	<div id="root"></div>

	<script type="text/babel">
		const { useState, useEffect, useRef, useCallback } = React;

		// Serial Connection Class
		class SerialConnection {
			constructor() {
				this.port = null;
				this.writer = null;
				this.reader = null;
				this.readerBuffer = '';
				this.connected = false;
				this.onDisconnect = null; // Callback for disconnect events
			}

			async connect(filters) {
				if (!('serial' in navigator)) {
					throw new Error('Web Serial API not supported in this browser');
				}

				this.port = await navigator.serial.requestPort({ filters });
				await this.port.open({ baudRate: 115200 });

				this.writer = this.port.writable.getWriter();
				this.reader = this.port.readable.getReader();
				this.connected = true;

				// Listen for disconnect events (when device is unplugged)
				this.port.addEventListener('disconnect', () => {
					console.log('Serial port disconnect event detected');
					this.connected = false;
					if (this.onDisconnect) {
						this.onDisconnect();
					}
				});

				console.log('Serial port connected');
				return this.port;
			}

			async disconnect() {
				this.connected = false;

				if (this.reader) {
					try {
						await this.reader.cancel();
						await this.reader.releaseLock();
					} catch (e) {
						console.warn('Error releasing reader:', e);
					}
					this.reader = null;
				}

				if (this.writer) {
					try {
						await this.writer.releaseLock();
					} catch (e) {
						console.warn('Error releasing writer:', e);
					}
					this.writer = null;
				}

				if (this.port) {
					try {
						await this.port.close();
					} catch (e) {
						console.warn('Error closing port:', e);
					}
					this.port = null;
				}

				this.readerBuffer = '';
				console.log('Serial port disconnected');
			}

			async sendCommand(command, timeout = 5000) {
				if (!this.connected || !this.writer || !this.reader) {
					throw new Error('Not connected to device');
				}

				try {
					const commandStr = JSON.stringify(command) + '\r\n';
					const encoder = new TextEncoder();
					await this.writer.write(encoder.encode(commandStr));
					console.log('Sent:', commandStr.trim());

					const response = await this.readResponse(timeout);
					return response;
				} catch (error) {
					console.error('Command error:', error.message);
					throw error;
				}
			}

			async readResponse(timeout = 5000) {
				if (!this.reader) {
					throw new Error('No reader available');
				}

				return new Promise((resolve, reject) => {
					const timeoutId = setTimeout(() => {
						reject(new Error(`Response timeout after ${timeout}ms`));
					}, timeout);

					(async () => {
						try {
							while (true) {
								const { value, done } = await this.reader.read();
								if (done) {
									clearTimeout(timeoutId);
									this.connected = false;
									reject(new Error('Device disconnected (read stream ended)'));
									return;
								}

								const decoder = new TextDecoder();
								const newData = decoder.decode(value);
								this.readerBuffer += newData;

								const endIndex = this.readerBuffer.indexOf('\r\n');
								if (endIndex !== -1) {
									const line = this.readerBuffer.substring(0, endIndex).trim();
									this.readerBuffer = this.readerBuffer.substring(endIndex + 2);

									if (line) {
										console.log('Received:', line);
										try {
											const data = JSON.parse(line);
											clearTimeout(timeoutId);
											resolve(data);
											return;
										} catch (e) {
											console.warn('Non-JSON response:', line);
										}
									}
								}
							}
						} catch (error) {
							clearTimeout(timeoutId);
							if (error.name === 'NetworkError' || error.name === 'InvalidStateError' ||
								error.message.includes('closed') || error.message.includes('disconnected')) {
								this.connected = false;
							}
							reject(error);
						}
					})();
				});
			}

			async enterBootloader() {
				if (!this.connected || !this.port) {
					throw new Error('Device not connected');
				}

				console.log('Triggering bootloader mode...');

				await this.disconnect();

				await new Promise(resolve => setTimeout(resolve, 500));

				const bootloaderPort = await navigator.serial.requestPort({
					filters: [
						{
							usbVendorId: 0x2E8A,
							usbProductId: 0x000A
						}
					]
				});

				try {
					await bootloaderPort.open({ baudRate: 1200 });
					await bootloaderPort.close();
				} catch (error) {
					// Ignore port open/close errors - device resets into bootloader mode so quickly
					// that the OS may not see a successful port open. This is expected behavior.
					console.log('Port open/close error (expected when entering bootloader):', error.message);
				}

				console.log('Device should now be in bootloader mode');
			}
		}

		// Device States
		const DeviceState = {
			NO_DEVICE: 'no_device',
			CONNECTING: 'connecting',
			PROBING: 'probing',
			INCOMPATIBLE: 'incompatible',
			FIRST_TIME: 'first_time',
			CONNECTED: 'connected',
			DISCONNECTED: 'disconnected',
			BOOTLOADER: 'bootloader'
		};

		// Device Class
		class Device {
			constructor(id, port) {
				this.id = id;
				this.port = port;
				this.connection = new SerialConnection();
				this.state = DeviceState.CONNECTING;
				this.pollingInterval = null;
				this.pageVisible = true;

				this.productInfo = null;
				this.firmwareVersion = null;
				this.userInfo = null;
				this.status = null;

				this.temperatureCurrent = null;
				this.temperatureTarget = null;
				this.deviceState = 0; // 0=locked, 1=idle, 2=active

				// Set up disconnect callback on connection
				this.connection.onDisconnect = () => {
					this.handleDisconnection();
				};
			}

			async connect() {
				try {
					await this.connection.connect([
						{
							usbVendorId: 0x2E8A,
							usbProductId: 0x000A
						}
					]);
					this.state = DeviceState.PROBING;
					if (this.onStateChange) {
						this.onStateChange();
					}
					await this.probe();
				} catch (error) {
					console.error('Connection error:', error);
					this.state = DeviceState.DISCONNECTED;
					if (this.onStateChange) {
						this.onStateChange();
					}
					throw error;
				}
			}

			async probe() {
				try {
					const productResponse = await this.connection.sendCommand({ action: 'product_information_get' });
					// Only proceed if we get a successful response with SLTO00001 product code
					if (productResponse.result === 'success' && productResponse.number === 'SLTO00001') {
						this.productInfo = productResponse;
						const versionResponse = await this.connection.sendCommand({ action: 'firmware_version_get' });
						if (versionResponse.result === 'success') {
							this.firmwareVersion = versionResponse.string;
							const parsed = this.parseFirmwareVersion(this.firmwareVersion);
							if (parsed && parsed.major >= 1) {
								const userResponse = await this.connection.sendCommand({ action: 'user_information_get' });
								if (userResponse.result === 'success' && userResponse.user) {
									this.userInfo = userResponse.user;
									// Set to CONNECTED even for first-time users - they'll see preferences tab with alert
									this.state = DeviceState.CONNECTED;
									await this.loadInitialData();
									this.startStatusPolling();
								} else {
									this.state = DeviceState.CONNECTED;
									await this.loadInitialData();
									this.startStatusPolling();
								}
							} else {
								// Firmware < 1.0.0: set to CONNECTED but will show only firmware tab
								this.state = DeviceState.CONNECTED;
							}
						} else {
							// Couldn't get firmware version: set to CONNECTED but will show only firmware tab
							this.state = DeviceState.CONNECTED;
						}
					} else {
						// Product information not available or not SLTO00001 - treat as unknown device
						// Keep in PROBING state to show unknown device card
						this.state = DeviceState.PROBING;
					}
					if (this.onStateChange) {
						this.onStateChange();
					}
				} catch (error) {
					console.error('Probe error:', error);
					this.state = DeviceState.DISCONNECTED;
					if (this.onStateChange) {
						this.onStateChange();
					}
				}
			}

			parseFirmwareVersion(versionString) {
				if (!versionString) return null;
				const match = versionString.match(/v?(\d+)\.(\d+)\.(\d+)/);
				if (!match) return null;
				return {
					major: parseInt(match[1], 10),
					minor: parseInt(match[2], 10),
					patch: parseInt(match[3], 10)
				};
			}

			async loadInitialData() {
				try {
					const statusResponse = await this.connection.sendCommand({ action: 'controller_status_get' });
					if (statusResponse.result === 'success') {
						// Status data is directly in the response, not nested under 'status'
						this.updateStatus(statusResponse);
					}
					const targetResponse = await this.connection.sendCommand({ action: 'controller_temperature_target_get' });
					if (targetResponse.result === 'success' && targetResponse.temperature_c !== undefined) {
						this.temperatureTarget = targetResponse.temperature_c;
					}
				} catch (error) {
					console.error('Error loading initial data:', error);
				}
			}

			updateStatus(status) {
				this.status = status;
				const oldState = this.deviceState;

				// Extract temperature from status response
				if (status.temperature) {
					if (status.temperature.measured !== undefined) {
						this.temperatureCurrent = status.temperature.measured;
					}
					if (status.temperature.target !== undefined) {
						this.temperatureTarget = status.temperature.target;
					}
				}
				if (status.state !== undefined) {
					if (typeof status.state === 'string') {
						if (status.state === 'locked') this.deviceState = 0;
						else if (status.state === 'idle' || status.state === 'asleep') this.deviceState = 1;
						else if (status.state === 'active') this.deviceState = 2;
					} else {
						this.deviceState = status.state;
					}
				}
				// Restart polling with new interval if state changed
				if (oldState !== this.deviceState && this.pollingInterval) {
					this.startStatusPolling();
				}
			}

			startStatusPolling() {
				this.stopStatusPolling();
				if (!this.pageVisible) return;
				if (this.state !== DeviceState.CONNECTED) return;

				const interval = this.deviceState === 2 ? 100 : 500;
				this.pollingInterval = setInterval(async () => {
					if (this.state === DeviceState.CONNECTED && this.pageVisible) {
						try {
							const response = await this.connection.sendCommand({ action: 'controller_status_get' });
							if (response.result === 'success') {
								// Status data is directly in the response, not nested under 'status'
								this.updateStatus(response);
								if (this.onStatusUpdate) {
									this.onStatusUpdate();
								}
								if (this.onStateChange) {
									this.onStateChange();
								}
							}
						} catch (error) {
							console.error('Status polling error:', error);
							if (error.message.includes('disconnected') || error.message.includes('closed')) {
								this.handleDisconnection();
							}
						}
					}
				}, interval);
			}

			stopStatusPolling() {
				if (this.pollingInterval) {
					clearInterval(this.pollingInterval);
					this.pollingInterval = null;
				}
			}

			setPageVisible(visible) {
				this.pageVisible = visible;
				if (visible && this.state === DeviceState.CONNECTED) {
					this.startStatusPolling();
				} else {
					this.stopStatusPolling();
				}
			}

			handleDisconnection() {
				this.stopStatusPolling();
				this.state = DeviceState.DISCONNECTED;
				if (this.onDisconnect) {
					this.onDisconnect();
				}
				if (this.onStateChange) {
					this.onStateChange();
				}
			}

			async disconnect() {
				this.stopStatusPolling();
				await this.connection.disconnect();
				this.state = DeviceState.DISCONNECTED;
				if (this.onStateChange) {
					this.onStateChange();
				}
			}

			async enterBootloader() {
				this.stopStatusPolling();
				this.state = DeviceState.DISCONNECTED;
				if (this.onStateChange) {
					this.onStateChange();
				}
				try {
					await this.connection.enterBootloader();
				} catch (error) {
					// Ignore errors - device may reset into bootloader before port open completes
					// This is expected behavior and doesn't indicate failure
					console.log('Bootloader entry (error may be expected):', error.message);
				}
				// Set state to bootloader regardless of errors - the device is in bootloader mode
				this.state = DeviceState.BOOTLOADER;
				if (this.onStateChange) {
					this.onStateChange();
				}
			}
		}

		// Device Manager
		class DeviceManager {
			constructor() {
				this.devices = new Map();
				this.nextId = 1;
				this.onDeviceChange = null;
			}

			async addDevice(port) {
				const id = `device_${this.nextId++}`;
				const device = new Device(id, port);
				device.onStateChange = () => {
					if (this.onDeviceChange) {
						this.onDeviceChange();
					}
				};
				device.onStatusUpdate = () => {
					if (this.onDeviceChange) {
						this.onDeviceChange();
					}
				};
				device.onDisconnect = () => {
					if (this.onDeviceChange) {
						this.onDeviceChange();
					}
				};
				this.devices.set(id, device);
				try {
					await device.connect();
				} catch (error) {
					console.error('Failed to connect device:', error);
				}
				if (this.onDeviceChange) {
					this.onDeviceChange();
				}
				return device;
			}

			removeDevice(id) {
				const device = this.devices.get(id);
				if (device) {
					device.disconnect();
					this.devices.delete(id);
					if (this.onDeviceChange) {
						this.onDeviceChange();
					}
				}
			}

			getDevices() {
				return Array.from(this.devices.values());
			}
		}

		// Icon Editor Utilities
		const IconUtils = {
			bytesToBitmap(bytes) {
				const pixels = Array(16 * 16).fill(false);
				for (let i = 0; i < 32; i++) {
					const byte = bytes[i] || 0;
					for (let bit = 0; bit < 8; bit++) {
						const pixelIndex = i * 8 + bit;
						if (pixelIndex < 256) {
							pixels[pixelIndex] = (byte & (1 << (7 - bit))) !== 0;
						}
					}
				}
				return pixels;
			},

			bitmapToBytes(pixels) {
				const bytes = Array(32).fill(0);
				for (let i = 0; i < 32; i++) {
					let byte = 0;
					for (let bit = 0; bit < 8; bit++) {
						const pixelIndex = i * 8 + bit;
						if (pixelIndex < 256 && pixels[pixelIndex]) {
							byte |= (1 << (7 - bit));
						}
					}
					bytes[i] = byte;
				}
				return bytes;
			},

			async processImageToBitmap(image, threshold = 128) {
				const canvas = document.createElement('canvas');
				canvas.width = 16;
				canvas.height = 16;
				const ctx = canvas.getContext('2d');

				ctx.fillStyle = '#FFFFFF';
				ctx.fillRect(0, 0, 16, 16);

				ctx.imageSmoothingEnabled = true;
				ctx.imageSmoothingQuality = 'high';

				ctx.drawImage(image, 0, 0, 16, 16);

				const imageData = ctx.getImageData(0, 0, 16, 16);
				const data = imageData.data;

				const pixels = [];
				for (let i = 0; i < data.length; i += 4) {
					const r = data[i];
					const g = data[i + 1];
					const b = data[i + 2];
					const a = data[i + 3];

					if (a < 128) {
						pixels.push(false);
						continue;
					}

					const gray = Math.round(0.299 * r + 0.587 * g + 0.114 * b);
					pixels.push(gray < threshold);
				}

				return pixels;
			}
		};

		// Icon Editor Component
		function IconEditor({ pixels, onChange, onDirtyChange }) {
			const [isDragging, setIsDragging] = useState(false);
			const [dragAction, setDragAction] = useState(null);
			const editorRef = useRef(null);

			const handlePixelStart = (e, row, col) => {
				e.preventDefault();
				const index = row * 16 + col;
				const action = !pixels[index];
				setDragAction(action);
				setIsDragging(true);
				const newPixels = [...pixels];
				newPixels[index] = action;
				onChange(newPixels);
				if (onDirtyChange) onDirtyChange(true);
			};

			const handlePixelEnter = (e, row, col) => {
				if (isDragging && dragAction !== null) {
					e.preventDefault();
					const index = row * 16 + col;
					const newPixels = [...pixels];
					newPixels[index] = dragAction;
					onChange(newPixels);
					if (onDirtyChange) onDirtyChange(true);
				}
			};

			const handleTouchMove = (e) => {
				if (isDragging) {
					e.preventDefault();
					const touch = e.touches[0] || e.changedTouches[0];
					const element = document.elementFromPoint(touch.clientX, touch.clientY);
					if (element && element.dataset.row !== undefined) {
						const row = parseInt(element.dataset.row);
						const col = parseInt(element.dataset.col);
						const index = row * 16 + col;
						const newPixels = [...pixels];
						newPixels[index] = dragAction;
						onChange(newPixels);
						if (onDirtyChange) onDirtyChange(true);
					}
				}
			};

			useEffect(() => {
				const handleMouseUp = () => {
					setIsDragging(false);
					setDragAction(null);
				};

				const handleTouchEnd = () => {
					setIsDragging(false);
					setDragAction(null);
				};

				document.addEventListener('mouseup', handleMouseUp);
				document.addEventListener('touchend', handleTouchEnd);
				document.addEventListener('touchcancel', handleTouchEnd);

				return () => {
					document.removeEventListener('mouseup', handleMouseUp);
					document.removeEventListener('touchend', handleTouchEnd);
					document.removeEventListener('touchcancel', handleTouchEnd);
				};
			}, []);

			const clearIcon = () => {
				const newPixels = Array(16 * 16).fill(false);
				onChange(newPixels);
				if (onDirtyChange) onDirtyChange(true);
			};


			const handleImageLoad = async (e) => {
				const file = e.target.files[0];
				if (!file) return;

				try {
					const image = await new Promise((resolve, reject) => {
						const reader = new FileReader();
						reader.onload = (e) => {
							const img = new Image();
							img.onload = () => resolve(img);
							img.onerror = () => reject(new Error('Failed to load image'));
							img.src = e.target.result;
						};
						reader.onerror = () => reject(new Error('Failed to read file'));
						reader.readAsDataURL(file);
					});

					const newPixels = await IconUtils.processImageToBitmap(image, 128);
					onChange(newPixels);
					if (onDirtyChange) onDirtyChange(true);
				} catch (error) {
					console.error('Error loading image:', error);
				}

				e.target.value = '';
			};

			return (
				<div className="d-flex flex-row">
					<div
						ref={editorRef}
						style={{
							height: '92px',
							width: '92px',
							display: 'inline-block',
							border: '1px solid #333',
							borderRadius: '6px',
							padding: '5px',
							background: 'black',
							userSelect: 'none',
						}}
					>
						{Array.from({ length: 16 }, (_, row) => (
							<div
								key={row}
								className="icon-row"
								style={{ display: 'block', lineHeight: 0, height: '5px' }}
							>
								{Array.from({ length: 16 }, (_, col) => {
									const index = row * 16 + col;
									return (
										<div
											key={col}
											data-row={row}
											data-col={col}
											className={`icon-pixel ${pixels[index] ? 'black' : ''}`}
											style={{
												border: '0px',
												display: 'inline-block',
												cursor: 'pointer',
												backgroundColor: pixels[index] ? 'white' : 'black',
												padding: 0,
												margin: 0,
												boxSizing: 'border-box',
												touchAction: 'none'
											}}
											onMouseDown={(e) => handlePixelStart(e, row, col)}
											onMouseEnter={(e) => handlePixelEnter(e, row, col)}
											onTouchStart={(e) => handlePixelStart(e, row, col)}
											onTouchMove={handleTouchMove}
										/>
									);
								})}
							</div>
						))}
					</div>
					<div className="d-flex flex-column ms-3">
						<button
							type="button"
							className="btn btn-light border mb-3"
							onClick={clearIcon}
							aria-label="Clear icon"
						>
							<i className="bi bi-eraser"></i>
						</button>
						<label className="btn btn-light border" style={{ marginBottom: 0 }} aria-label="Load image">
							<i className="bi bi-file-earmark-arrow-up"></i>
							<input
								type="file"
								accept="image/*"
								style={{ display: 'none' }}
								onChange={handleImageLoad}
							/>
						</label>
					</div>
				</div>
			);
		}

		// Control Tab Component
		function ControlTab({ device, onStateChange }) {
			const [localTarget, setLocalTarget] = useState(device?.temperatureTarget || 300);
			const [updateTrigger, setUpdateTrigger] = useState(0);

			useEffect(() => {
				if (device?.temperatureTarget !== undefined) {
					setLocalTarget(device.temperatureTarget);
				}
			}, [device?.temperatureTarget]);

			// Listen for status updates to force re-render
			useEffect(() => {
				if (!device) return;
				const originalOnStatusUpdate = device.onStatusUpdate;
				device.onStatusUpdate = () => {
					if (originalOnStatusUpdate) originalOnStatusUpdate();
					setUpdateTrigger(prev => prev + 1);
				};
				return () => {
					device.onStatusUpdate = originalOnStatusUpdate;
				};
			}, [device]);

			if (!device) return null;

			const handleLockToggle = async () => {
				try {
					if (device.deviceState === 0) {
						await device.connection.sendCommand({ action: 'controller_unlock' });
					} else {
						await device.connection.sendCommand({ action: 'controller_lock' });
					}
					// Get updated status after toggle
					const statusResponse = await device.connection.sendCommand({ action: 'controller_status_get' });
					if (statusResponse.result === 'success') {
						device.updateStatus(statusResponse);
					}
					if (onStateChange) onStateChange();
				} catch (error) {
					console.error('Lock toggle error:', error);
				}
			};

			const handleTempChange = async (delta) => {
				const newTarget = Math.max(0, Math.min(400, localTarget + delta));
				setLocalTarget(newTarget);
				try {
					await device.connection.sendCommand({
						action: 'controller_temperature_target_set',
						temperature_c: newTarget
					});
					if (onStateChange) onStateChange();
				} catch (error) {
					console.error('Temperature set error:', error);
				}
			};

			const lockIcon = device.deviceState === 0 ? 'bi-lock' : 'bi-unlock';
			const progressPercentage = Math.min(Math.max(device.temperatureCurrent ? (device.temperatureCurrent / 400) * 100 : 0, 0), 100);
			const progressColor = device.deviceState === 2 ? 'bg-primary' : 'bg-secondary';

			return (
				<div>
					<label className="form-label">
						<i className="bi bi-thermometer-half"></i> Heating
					</label>
					<div className="row">
						<div className="col-auto">
							<button
								type="button"
								className="btn btn-light border"
								aria-label={device.deviceState === 0 ? 'Unlock heating' : 'Lock heating'}
								onClick={handleLockToggle}
							>
								<i className={`bi ${lockIcon}`}></i>
							</button>
						</div>
						<div className="col">
							<div
								className="progress-stacked border"
								style={{ height: '38px', backgroundColor: 'var(--bs-tertiary-bg)' }}
							>
								<div
									className="progress"
									role="progressbar"
									aria-label="Current temperature"
									aria-valuenow={device.temperatureCurrent || 0}
									aria-valuemin={0}
									aria-valuemax={400}
									style={{ width: `${progressPercentage}%`, height: '38px' }}
								>
									<div
										className={`progress-bar progress-bar-striped ${device.deviceState === 2 ? 'progress-bar-animated' : ''} ${progressColor} text-bg-primary`}
									>
										{device.temperatureCurrent ? `${device.temperatureCurrent.toFixed(0)} °C` : '-- °C'}
									</div>
								</div>
							</div>
						</div>
						<div className="col-auto">
							<div className="input-group" role="group" aria-label="Temperature control">
								<button
									type="button"
									className="btn btn-light border"
									aria-label="Decrease temperature by 10°C"
									onClick={() => handleTempChange(-10)}
								>
									<i className="bi bi-dash"></i>
								</button>
								<span className="input-group-text">{localTarget.toFixed(0)} °C</span>
								<button
									type="button"
									className="btn btn-light border"
									aria-label="Increase temperature by 10°C"
									onClick={() => handleTempChange(10)}
								>
									<i className="bi bi-plus"></i>
								</button>
							</div>
						</div>
					</div>
				</div>
			);
		}

		// Preferences Tab Component
		function PreferencesTab({ device, onStateChange }) {
			const [nameLine1, setNameLine1] = useState('');
			const [nameLine2, setNameLine2] = useState('');
			const [iconPixels, setIconPixels] = useState(Array(16 * 16).fill(false));
			const [isDirty, setIsDirty] = useState(false);
			const [isLoading, setIsLoading] = useState(false);
			const [errorMessage, setErrorMessage] = useState(null);

			// Check if it's first time (default name values)
			const isFirstTime = device?.userInfo?.name?.[0] === 'Customize at' && device?.userInfo?.name?.[1] === 'solder.ninja';

			useEffect(() => {
				if (device && device.userInfo) {
					if (device.userInfo.name && Array.isArray(device.userInfo.name)) {
						setNameLine1(device.userInfo.name[0] || '');
						setNameLine2(device.userInfo.name[1] || '');
					}
					if (device.userInfo.icon && Array.isArray(device.userInfo.icon)) {
						const iconBytes = device.userInfo.icon.map(b => parseInt(b));
						setIconPixels(IconUtils.bytesToBitmap(iconBytes));
					}
					setIsDirty(false);
				}
			}, [device?.userInfo]);

			const handleSave = async () => {
				if (!device) return;

				const line1 = nameLine1.trim();
				const line2 = nameLine2.trim();

				if (line1.length === 0 || line2.length === 0) {
					setErrorMessage('Both name lines must have at least 1 character');
					return;
				}
				if (line1.length > 12 || line2.length > 12) {
					setErrorMessage('Name lines must be 12 characters or less');
					return;
				}

				setIsLoading(true);
				setErrorMessage(null);
				try {
					const iconBytes = IconUtils.bitmapToBytes(iconPixels);
					const response = await device.connection.sendCommand({
						action: 'user_information_set',
						icon: iconBytes,
						name: [line1, line2]
					});

					if (response.result === 'failure') {
						const errorMsg = response.errors && response.errors.length > 0
							? response.errors.join(', ')
							: 'Failed to save user information';
						setErrorMessage(errorMsg);
					} else {
						// Reload user information from device to update the UI
						try {
							const userResponse = await device.connection.sendCommand({ action: 'user_information_get' });
							if (userResponse.result === 'success' && userResponse.user) {
								device.userInfo = userResponse.user;
								// Update local state immediately to reflect changes
								if (userResponse.user.name && Array.isArray(userResponse.user.name)) {
									setNameLine1(userResponse.user.name[0] || '');
									setNameLine2(userResponse.user.name[1] || '');
								}
								if (userResponse.user.icon && Array.isArray(userResponse.user.icon)) {
									const iconBytes = userResponse.user.icon.map(b => parseInt(b));
									setIconPixels(IconUtils.bytesToBitmap(iconBytes));
								}
							}
						} catch (error) {
							console.error('Error reloading user information:', error);
						}

						setIsDirty(false);
						setErrorMessage(null);
						if (onStateChange) onStateChange();
					}
				} catch (error) {
					console.error('Save error:', error);
					setErrorMessage(error.message || 'Failed to save user information');
				} finally {
					setIsLoading(false);
				}
			};

			return (
				<div>
					{isFirstTime && (
						<div className="alert alert-success align-items-center mb-3" role="alert">
							<p className="mb-0">It looks like you're using your Solder Ninja Pen for the first time. Did you know you can make it your own by displaying your name at startup?</p>
						</div>
					)}
					<div className="row">
						<div className="col">
							<label className="form-label">
								<i className="bi bi-person"></i> User information
							</label>
						</div>
					</div>
					<div className="row">
						<div className="col-auto">
							<IconEditor
								pixels={iconPixels}
								onChange={setIconPixels}
								onDirtyChange={setIsDirty}
							/>
						</div>
						<div className="col">
							<input
								type="text"
								className="form-control mb-3"
								placeholder="First name"
								maxlength={12}
								value={nameLine1}
								onChange={(e) => {
									setNameLine1(e.target.value);
									setIsDirty(true);
									setErrorMessage(null);
								}}
							/>
							<input
								type="text"
								className="form-control"
								placeholder="Last name"
								maxlength={12}
								value={nameLine2}
								onChange={(e) => {
									setNameLine2(e.target.value);
									setIsDirty(true);
									setErrorMessage(null);
								}}
							/>
						</div>
					</div>
					{errorMessage && (
						<div className="row mt-3">
							<div className="col">
								<div className="alert alert-danger" role="alert">
									{errorMessage}
								</div>
							</div>
						</div>
					)}
					{isDirty && (
						<div className="row mt-3">
							<div className="col">
								<button
									type="button"
									className="btn btn-light border w-100"
									onClick={handleSave}
									disabled={isLoading}
								>
									<i className="bi bi-floppy"></i> Save
								</button>
							</div>
						</div>
					)}
				</div>
			);
		}

		// Information Tab Component
		function InformationTab({ device }) {
			const [diagnostics, setDiagnostics] = useState({ heatingTime: null, maxVoltage: null });

			useEffect(() => {
				if (!device || !device.connection) return;

				const fetchDiagnostics = async () => {
					try {
						// Get heating time
						try {
							const heatingTimeResponse = await device.connection.sendCommand({ action: 'heating_time_get' });
							if (heatingTimeResponse.result === 'success' && heatingTimeResponse.heating && heatingTimeResponse.heating.time !== undefined) {
								setDiagnostics(prev => ({
									...prev,
									heatingTime: heatingTimeResponse.heating.time
								}));
							}
						} catch (error) {
							console.error('Error fetching heating time:', error);
						}

						// Get max USB voltage
						try {
							const voltageResponse = await device.connection.sendCommand({ action: 'usb_voltage_max_get' });
							if (voltageResponse.result === 'success' && voltageResponse.usb && voltageResponse.usb.voltage_max !== undefined) {
								setDiagnostics(prev => ({
									...prev,
									maxVoltage: voltageResponse.usb.voltage_max
								}));
							}
						} catch (error) {
							console.error('Error fetching max voltage:', error);
						}
					} catch (error) {
						console.error('Error fetching diagnostics:', error);
					}
				};

				fetchDiagnostics();
			}, [device]);

			if (!device || !device.productInfo) return null;

			// Format heating time (seconds to hours and minutes)
			const formatHeatingTime = (seconds) => {
				if (seconds === null || seconds === undefined) return '--';
				const hours = Math.floor(seconds / 3600);
				const minutes = Math.floor((seconds % 3600) / 60);
				if (hours > 0) {
					return `${hours}h ${minutes}m`;
				}
				return `${minutes}m`;
			};

			return (
				<div>
					<div className="row">
						<label className="form-label">
							<i className="bi bi-motherboard"></i> Product
						</label>
					</div>
					<div className="row">
						<div className="col-3">
							<strong>Code:</strong>
						</div>
						<div className="col-9">{device.productInfo.number || '--'}</div>
					</div>
					<div className="row">
						<div className="col-3">
							<strong>Revision:</strong>
						</div>
						<div className="col-9">{device.productInfo.revision || '--'}</div>
					</div>
					<div className="row">
						<div className="col-3">
							<strong>Serial:</strong>
						</div>
						<div className="col-9">{device.productInfo.serial || '--'}</div>
					</div>
					<div className="row mt-3">
						<label className="form-label">
							<i className="bi bi-heart-pulse"></i> Diagnostics
						</label>
					</div>
					<div className="row">
						<div className="col-3">
							<strong>Soldering time:</strong>
						</div>
						<div className="col-9">{formatHeatingTime(diagnostics.heatingTime)}</div>
					</div>
					<div className="row">
						<div className="col-3">
							<strong>Max voltage:</strong>
						</div>
						<div className="col-9">{diagnostics.maxVoltage !== null ? `${diagnostics.maxVoltage.toFixed(1)} V` : '--'}</div>
					</div>
				</div>
			);
		}

		// Firmware Tab Component
		function FirmwareTab({ device, onStateChange }) {
			const [latestFirmware, setLatestFirmware] = useState(null);
			const [isChecking, setIsChecking] = useState(false);
			const [isUpdating, setIsUpdating] = useState(false);

			useEffect(() => {
				if (device && device.firmwareVersion) {
					checkForUpdates();
				}
			}, [device?.firmwareVersion]);

			const checkForUpdates = async () => {
				if (!device || !device.firmwareVersion) return;

				setIsChecking(true);
				try {
					const response = await fetch('https://api.github.com/repos/sitronlabs/Solder-Ninja-Pen-Firmware/releases/latest');
					if (!response.ok) {
						console.error('Failed to check for updates');
						return;
					}

					const release = await response.json();
					const uf2Asset = release.assets.find(asset => asset.name.endsWith('.uf2'));

					if (uf2Asset) {
						const filenameWithoutExt = uf2Asset.name.replace(/\.uf2$/i, '');
						const versionMatch = filenameWithoutExt.match(/(?:.*-)?(v?\d+\.\d+\.\d+[\+\-].*)/);
						const releaseVersion = versionMatch ? versionMatch[1] : filenameWithoutExt;

						setLatestFirmware({
							version: releaseVersion,
							uf2Url: uf2Asset.browser_download_url,
							uf2Name: uf2Asset.name,
							releaseUrl: release.html_url
						});
					}
				} catch (error) {
					console.error('Error checking for updates:', error);
				} finally {
					setIsChecking(false);
				}
			};

			const parseFirmwareVersion = (versionString) => {
				if (!versionString) return null;
				const match = versionString.match(/v?(\d+)\.(\d+)\.(\d+)/);
				if (!match) return null;
				return {
					major: parseInt(match[1], 10),
					minor: parseInt(match[2], 10),
					patch: parseInt(match[3], 10)
				};
			};

			const compareVersions = (v1, v2) => {
				if (!v1 || !v2) return 0;
				if (v1.major !== v2.major) return v1.major < v2.major ? -1 : 1;
				if (v1.minor !== v2.minor) return v1.minor < v2.minor ? -1 : 1;
				if (v1.patch !== v2.patch) return v1.patch < v2.patch ? -1 : 1;
				return 0;
			};

			const handleUpdate = async () => {
				if (!device || !latestFirmware) return;

				setIsUpdating(true);
				try {
					await device.enterBootloader();

					await new Promise(resolve => setTimeout(resolve, 1000));

					const a = document.createElement('a');
					a.href = latestFirmware.uf2Url;
					a.download = latestFirmware.uf2Name;
					a.target = '_blank';
					document.body.appendChild(a);
					a.click();
					document.body.removeChild(a);

					console.log('Firmware download started');
				} catch (error) {
					console.error('Update error:', error);
				} finally {
					setIsUpdating(false);
				}
			};

			if (!device) return null;

			const currentVersion = parseFirmwareVersion(device.firmwareVersion);
			const latestVersion = latestFirmware ? parseFirmwareVersion(latestFirmware.version) : null;
			const needsUpdate = currentVersion && currentVersion.major < 1;
			const updateAvailable = latestVersion && currentVersion && compareVersions(currentVersion, latestVersion) < 0;

			return (
				<div>
					{needsUpdate && (
						<div className="alert alert-warning align-items-center" role="alert">
							<h4 className="alert-heading">Update needed</h4>
							<p className="mb-0">The webapp uses a richer set of commands than the firmware on your device currently supports, so we need to update the firmware first. It should take less than a minute.</p>
						</div>
					)}
					{updateAvailable && !needsUpdate && (
						<div className="alert alert-success align-items-center" role="alert">
							<h4 className="alert-heading">Update available</h4>
							<p className="mb-0">It looks like a new firmware is available. If you want to update now, click the button below. It should take less than a minute.</p>
						</div>
					)}
					<div className="row">
						<div className="col-3">
							<label className="form-label">
								<i className="bi bi-motherboard"></i> <strong>Local version:</strong>
							</label>
						</div>
						<div className="col-9">{device.firmwareVersion || '--'}</div>
					</div>
					{latestFirmware && (
						<div className="row">
							<div className="col-3">
								<label className="form-label">
									<i className="bi bi-github"></i> <strong>Online version:</strong>
								</label>
							</div>
							<div className="col-9">
								{latestFirmware.version} (<a href={latestFirmware.releaseUrl} target="_blank" rel="noopener noreferrer">release notes</a>)
							</div>
						</div>
					)}
					{(needsUpdate || updateAvailable) && (
						<div className="row mt-3">
							<div className="col">
								<button
									type="button"
									className="btn btn-light border w-100"
									onClick={handleUpdate}
									disabled={isUpdating || isChecking}
								>
									{isUpdating ? 'Updating...' : 'Update'}
								</button>
							</div>
						</div>
					)}
				</div>
			);
		}

		// Device Card Component
		function DeviceCard({ device, deviceManager, onStateChange }) {
			// Check if firmware needs update (version < 1.0.0)
			const parseFirmwareVersion = (versionString) => {
				if (!versionString) return null;
				const match = versionString.match(/v?(\d+)\.(\d+)\.(\d+)/);
				if (!match) return null;
				return {
					major: parseInt(match[1], 10),
					minor: parseInt(match[2], 10),
					patch: parseInt(match[3], 10)
				};
			};

			const firmwareVersion = device?.firmwareVersion;
			const parsedVersion = firmwareVersion ? parseFirmwareVersion(firmwareVersion) : null;
			const needsFirmwareUpdate = !parsedVersion || parsedVersion.major < 1;

			// Check if it's first time (default name values)
			const isFirstTime = device?.userInfo?.name?.[0] === 'Customize at' && device?.userInfo?.name?.[1] === 'solder.ninja';

			// Determine initial tab: firmware update takes priority, then first-time (preferences), then control
			const getInitialTab = () => {
				if (needsFirmwareUpdate) return 'firmware';
				if (isFirstTime) return 'preferences';
				return 'control';
			};

			const [activeTab, setActiveTab] = useState(getInitialTab());

			// Update tab when first-time status or firmware update need changes
			useEffect(() => {
				if (needsFirmwareUpdate) {
					setActiveTab('firmware');
				} else if (isFirstTime) {
					setActiveTab('preferences');
				}
			}, [isFirstTime, needsFirmwareUpdate]);

			if (!device) {
				if (!deviceManager) return null;
				return (
					<div className="card shadow-sm mx-auto" style={{ maxWidth: '40rem' }}>
						<div className="card-header">
							<button
								type="button"
								className="btn btn-light btn-lg w-100"
								aria-label="Connect to a new device"
								onClick={async () => {
									if (!deviceManager) return;
									try {
										await deviceManager.addDevice();
									} catch (error) {
										console.error('Connection error:', error);
									}
								}}
							>
								<i className="bi bi-usb-c"></i> Connect to a USB device
							</button>
						</div>
					</div>
				);
			}

			if (device.state === DeviceState.PROBING) {
				return (
					<div className="card shadow-sm mx-auto" style={{ maxWidth: '40rem' }}>
						<div className="card-header">
							<div className="row">
								<div className="col-auto">
									<div className="card-img-top placeholder rounded" style={{ height: '5rem', width: '5rem' }}></div>
								</div>
								<div className="col overflow-x-hidden">
									<h4 className="card-title mb-0 text-truncate d-inline-block w-100">Unknown device</h4>
									<p className="text-muted small">Connected via Web Serial API at 115200 bauds</p>
								</div>
								<div className="col-auto">
									<button
										type="button"
										className="btn btn-light"
										onClick={() => deviceManager && deviceManager.removeDevice(device.id)}
									>
										<i className="bi bi-x-lg"></i>
									</button>
								</div>
							</div>
						</div>
					</div>
				);
			}

			if (device.state === DeviceState.DISCONNECTED || device.state === DeviceState.BOOTLOADER) {
				// Only show as Solder Ninja Pen if we have confirmed product info
				const isSolderNinjaPen = device.productInfo && device.productInfo.number === 'SLTO00001';
				const deviceName = isSolderNinjaPen ? 'Solder Ninja Pen' : 'Unknown device';
				const deviceImage = isSolderNinjaPen ? (
					<img
						src="images/product-slto00001.png"
						className="card-img-top"
						style={{ height: '5rem', width: '5rem' }}
						alt="Solder Ninja Pen"
					/>
				) : (
					<div className="card-img-top placeholder rounded" style={{ height: '5rem', width: '5rem' }}></div>
				);

				return (
					<div className="card shadow-sm mx-auto" style={{ maxWidth: '40rem' }}>
						<div className="card-header">
							<div className="row">
								<div className="col-auto">
									{deviceImage}
								</div>
								<div className="col overflow-x-hidden">
									<h4 className="card-title mb-0 text-truncate d-inline-block w-100">
										{deviceName}
										{isSolderNinjaPen && device.userInfo?.name?.[0] &&
											!(device.userInfo.name[0] === 'Customize at' && device.userInfo.name[1] === 'solder.ninja') &&
											<span> of {device.userInfo.name[0]}</span>}
									</h4>
									<p className="text-muted small">
										{device.state === DeviceState.BOOTLOADER ? 'Bootloader mode' : 'Disconnected'}
									</p>
								</div>
								<div className="col-auto">
									<button
										type="button"
										className="btn btn-light"
										onClick={() => deviceManager && deviceManager.removeDevice(device.id)}
									>
										<i className="bi bi-x-lg"></i>
									</button>
									<br />
									{device.state === DeviceState.DISCONNECTED && (
										<button
											type="button"
											className="btn btn-light"
											onClick={async () => {
												try {
													await device.connect();
													if (onStateChange) onStateChange();
												} catch (error) {
													console.error('Reconnection error:', error);
												}
											}}
										>
											<i className="bi bi-arrow-clockwise"></i>
										</button>
									)}
								</div>
							</div>
						</div>
					</div>
				);
			}

			if (device.state === DeviceState.CONNECTED) {
				// Don't show name if it's the first-time default values
				const isFirstTimeName = device.userInfo?.name?.[0] === 'Customize at' && device.userInfo?.name?.[1] === 'solder.ninja';
				const userName = (device.userInfo?.name?.[0] && !isFirstTimeName) ? ` of ${device.userInfo.name[0]}` : '';

				return (
					<div className="card shadow-sm mx-auto" style={{ maxWidth: '40rem' }}>
						<div className="card-header">
							<div className="row">
								<div className="col-auto">
									<img
										src="images/product-slto00001.png"
										className="card-img-top"
										style={{ height: '5rem', width: '5rem' }}
										alt="Solder Ninja Pen"
									/>
								</div>
								<div className="col overflow-x-hidden">
									<h4 className="card-title mb-0 text-truncate d-inline-block w-100">
										Solder Ninja Pen<span>{userName}</span>
									</h4>
									<p className="text-muted small">Connected via Web Serial API at 115200 bauds</p>
								</div>
								<div className="col-auto">
									<button
										type="button"
										className="btn btn-light"
										onClick={() => deviceManager && deviceManager.removeDevice(device.id)}
									>
										<i className="bi bi-x-lg"></i>
									</button>
								</div>
							</div>
							<ul className="nav nav-tabs card-header-tabs mt-2" role="tablist">
								<li className="nav-item" role="presentation">
									<a
										className={`nav-link ${activeTab === 'control' ? 'active' : ''} ${needsFirmwareUpdate ? 'disabled' : ''}`}
										href="#"
										onClick={(e) => {
											e.preventDefault();
											if (!needsFirmwareUpdate) {
												setActiveTab('control');
											}
										}}
										style={needsFirmwareUpdate ? { pointerEvents: 'none', opacity: 0.5 } : {}}
									>
										Control
									</a>
								</li>
								<li className="nav-item" role="presentation">
									<a
										className={`nav-link ${activeTab === 'preferences' ? 'active' : ''} ${needsFirmwareUpdate ? 'disabled' : ''}`}
										href="#"
										onClick={(e) => {
											e.preventDefault();
											if (!needsFirmwareUpdate) {
												setActiveTab('preferences');
											}
										}}
										style={needsFirmwareUpdate ? { pointerEvents: 'none', opacity: 0.5 } : {}}
									>
										Preferences
									</a>
								</li>
								<li className="nav-item" role="presentation">
									<a
										className={`nav-link ${activeTab === 'information' ? 'active' : ''} ${needsFirmwareUpdate ? 'disabled' : ''}`}
										href="#"
										onClick={(e) => {
											e.preventDefault();
											if (!needsFirmwareUpdate) {
												setActiveTab('information');
											}
										}}
										style={needsFirmwareUpdate ? { pointerEvents: 'none', opacity: 0.5 } : {}}
									>
										Info
									</a>
								</li>
								<li className="nav-item" role="presentation">
									<a
										className={`nav-link ${activeTab === 'firmware' ? 'active' : ''}`}
										href="#"
										onClick={(e) => {
											e.preventDefault();
											setActiveTab('firmware');
										}}
									>
										Firmware
									</a>
								</li>
							</ul>
						</div>
						<div className="card-body tab-content" style={{ minHeight: '15rem' }}>
							{activeTab === 'control' && <ControlTab device={device} onStateChange={onStateChange} />}
							{activeTab === 'preferences' && <PreferencesTab device={device} onStateChange={onStateChange} />}
							{activeTab === 'information' && <InformationTab device={device} />}
							{activeTab === 'firmware' && <FirmwareTab device={device} onStateChange={onStateChange} />}
						</div>
					</div>
				);
			}

			return null;
		}

		// Main App Component
		function App() {
			const [devices, setDevices] = useState([]);
			const deviceManagerRef = useRef(new DeviceManager());

			useEffect(() => {
				const manager = deviceManagerRef.current;
				manager.onDeviceChange = () => {
					setDevices([...manager.getDevices()]);
				};

				const handleVisibilityChange = () => {
					const isVisible = !document.hidden;
					manager.getDevices().forEach(device => {
						device.setPageVisible(isVisible);
					});
				};

				document.addEventListener('visibilitychange', handleVisibilityChange);

				return () => {
					document.removeEventListener('visibilitychange', handleVisibilityChange);
				};
			}, []);

			const handleStateChange = () => {
				setDevices([...deviceManagerRef.current.getDevices()]);
			};

			const currentDevice = devices.length > 0 ? devices[0] : null;

			return (
				<div className="container">
					<DeviceCard
						device={currentDevice}
						deviceManager={deviceManagerRef.current}
						onStateChange={handleStateChange}
					/>
				</div>
			);
		}

		// Render App
		const root = ReactDOM.createRoot(document.getElementById('root'));
		root.render(<App />);
	</script>
</body>

</html>