<!-- Soldering Iron Controller - Embeddable Version -->
<script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
<style>
	/* .soldering-iron-app {
		font-family: Arial, sans-serif;
		max-width: 800px;
		margin: 0 auto;
		padding: 20px;
		background-color: #f5f5f5;
	}

	.soldering-iron-app .container {
		background-color: white;
		padding: 20px;
		border-radius: 8px;
		box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
		margin-bottom: 20px;
	}

	.soldering-iron-app h1,
	.soldering-iron-app h2 {
		color: #333;
	} */

	.soldering-iron-app .status {
		padding: 10px;
		margin: 10px 0;
		border-radius: 4px;
	}

	.soldering-iron-app .status.connected {
		background-color: #d4edda;
		color: #155724;
		border: 1px solid #c3e6cb;
	}

	.soldering-iron-app .status.disconnected {
		background-color: #f8d7da;
		color: #721c24;
		border: 1px solid #f5c6cb;
	}

	.soldering-iron-app .settings-grid {
		display: grid;
		grid-template-columns: 1fr 1fr;
		gap: 20px;
	}

	.soldering-iron-app .setting-item {
		display: flex;
		justify-content: space-between;
		align-items: center;
		padding: 8px 0;
		border-bottom: 1px solid #eee;
	}

	.soldering-iron-app .log {
		background-color: #f8f9fa;
		border: 1px solid #dee2e6;
		border-radius: 4px;
		padding: 10px;
		height: 200px;
		overflow-y: auto;
		font-family: monospace;
		font-size: 12px;
	}

	.soldering-iron-app .icon-pixel {
		width: 12px;
		height: 12px;
		border: 1px solid #333;
		display: inline-block;
		cursor: pointer;
		background-color: black;
		padding: 0;
		margin: 0;
		box-sizing: border-box;
		user-select: none;
		-webkit-user-select: none;
		-moz-user-select: none;
		-ms-user-select: none;
	}

	.soldering-iron-app .icon-pixel.black {
		background-color: white;
	}

	.soldering-iron-app .icon-pixel:hover {
		border-color: #007bff;
	}

	.soldering-iron-app .icon-row {
		display: block;
		line-height: 0;
	}
</style>

<div class="soldering-iron-app">
	<h1>Solder Ninja Controller</h1>

	<!-- Connection Status -->
	<div class="container">
		<h2>Connection</h2>
		<div id="connectionStatus" class="status disconnected">Disconnected</div>
		<div class="controls">
			<button id="connectBtn">Connect to Device</button>
			<button id="disconnectBtn" disabled>Disconnect</button>
		</div>
	</div>

	<!-- Temperature Control -->
	<div class="container">
		<h2>Temperature Control</h2>
		<div id="deviceStatus">
			<div><strong>Temperature:</strong> <span id="currentTemp">--</span>°C</div>
			<div><strong>Target Temperature:</strong> <span id="targetTemp">--</span>°C</div>
			<div><strong>Heating:</strong> <span id="heatingStatus">--</span></div>
			<div><strong>Power:</strong> <span id="powerLevel">--</span>%</div>
		</div>
		<div class="controls">
			<label for="tempSlider">Target Temperature:</label>
			<input type="range" id="tempSlider" min="0" max="400" value="300" step="5">
			<input type="number" id="tempInput" min="0" max="400" value="300" step="5">
			<span>°C</span>
		</div>
		<div class="controls">
			<button id="maxBtn" disabled>Boost (400°C)</button>
		</div>
		<div class="controls">
			<button id="lockBtn" disabled>Lock Device</button>
			<button id="unlockBtn" disabled>Unlock Device</button>
		</div>
	</div>

	<!-- User Information -->
	<div class="container">
		<h2>Preferences</h2>
		<div class="settings-grid">
			<div>
				<h3>Name</h3>
				<div class="setting-item">
					<label for="userNameLine1">Line 1 (max 12 chars):</label>
					<input type="text" id="userNameLine1" maxlength="12" placeholder="First line">
				</div>
				<div class="setting-item">
					<label for="userNameLine2">Line 2 (max 12 chars):</label>
					<input type="text" id="userNameLine2" maxlength="12" placeholder="Second line">
				</div>
			</div>
			<div>
				<h3>Icon (16x16 bitmap)</h3>
				<div id="iconEditor"
					style="display: inline-block; border: 2px solid #333; padding: 5px; background: black; user-select: none;">
					<!-- Icon grid will be generated here -->
				</div>
				<div style="margin-top: 10px;">
					<button id="clearIconBtn" type="button" style="margin-right: 5px;">Clear Icon</button>
					<button id="invertIconBtn" type="button" style="margin-right: 5px;">Invert Icon</button>
					<button id="loadImageBtn" type="button">Load Image</button>
					<input type="file" id="imageFileInput" accept="image/*" style="display: none;">
				</div>
			</div>
		</div>
		<div class="controls">
			<button id="loadUserInfoBtn" disabled>Load User Info</button>
			<button id="saveUserInfoBtn" disabled>Save User Info</button>
		</div>
	</div>

	<!-- Device Settings -->
	<div class="container">
		<h2>Device Settings</h2>
		<div class="settings-grid">
			<div>
				<h3>Other Settings</h3>
				<div class="setting-item">
					<label for="displayBrightness">Display Brightness:</label>
					<input type="range" id="displayBrightness" min="1" max="10" value="7">
				</div>
			</div>
		</div>
		<div class="controls">
			<button id="saveSettingsBtn" disabled>Save Settings</button>
			<button id="loadSettingsBtn" disabled>Load Settings</button>
			<button id="resetSettingsBtn" disabled>Reset to Defaults</button>
		</div>
	</div>

	<!-- Communication Log -->
	<div class="container">
		<h2>Communication Log</h2>
		<div id="commLog" class="log"></div>
		<div class="controls">
			<button id="clearLogBtn">Clear Log</button>
		</div>
	</div>
</div>

<script>

	/* Serial port variables */
	let serial_port = null;
	let serial_port_connected = false;
	let serial_port_writer = null;
	let serial_port_reader = null;
	let serial_port_reader_buffer = ''; // Buffer for incomplete JSON responses

	/* Icon editor variables */
	let iconPixels = Array(16 * 16).fill(false); // 16x16 bitmap, false = inactive (black on OLED), true = active (white on OLED)
	let isDragging = false; // Track if mouse is being dragged
	let dragAction = null; // Track what action to perform during drag (true = set active/white, false = set inactive/black)

	/* Other */
	let statusUpdateInterval = null;
	let temperatureUpdateTimeout = null; // Debounce timer for temperature updates
	let continuousReadActive = false; // Track if continuous read loop is running

	// Initialize the application
	$(document).ready(function () {
		initializeEventHandlers();
		initializeIconEditor();
		updateConnectionStatus(false);
	});

	function initializeEventHandlers() {
		// Connection controls
		$('#connectBtn').click(connectToDevice);
		$('#disconnectBtn').click(disconnectFromDevice);

		// Temperature controls
		$('#tempSlider').on('input', function () {
			const newValue = $(this).val();
			$('#tempInput').val(newValue);
			// Automatically send temperature when slider changes (debounced)
			if (serial_port_connected) {
				// Clear any pending temperature update
				if (temperatureUpdateTimeout) {
					clearTimeout(temperatureUpdateTimeout);
				}
				// Debounce: wait 300ms after user stops dragging before sending
				temperatureUpdateTimeout = setTimeout(() => {
					setTemperature(parseFloat(newValue));
				}, 300);
			}
		});
		$('#tempInput').on('input', function () {
			const newValue = $(this).val();
			$('#tempSlider').val(newValue);
			// Automatically send temperature when input changes (debounced)
			if (serial_port_connected) {
				// Clear any pending temperature update
				if (temperatureUpdateTimeout) {
					clearTimeout(temperatureUpdateTimeout);
				}
				// Debounce: wait 500ms after user stops typing before sending
				temperatureUpdateTimeout = setTimeout(() => {
					setTemperature(parseFloat(newValue));
				}, 500);
			}
		});
		$('#maxBtn').click(() => setQuickTemp(400));
		$('#lockBtn').click(lockDevice);
		$('#unlockBtn').click(unlockDevice);

		// Settings controls
		$('#saveSettingsBtn').click(saveSettings);
		$('#loadSettingsBtn').click(loadSettings);
		$('#resetSettingsBtn').click(resetSettings);

		// User info controls
		$('#loadUserInfoBtn').click(loadUserInfo);
		$('#saveUserInfoBtn').click(saveUserInfo);
		$('#clearIconBtn').click(clearIcon);
		$('#invertIconBtn').click(invertIcon);
		$('#loadImageBtn').click(() => $('#imageFileInput').click());
		$('#imageFileInput').change(handleImageLoad);

		// Log controls
		$('#clearLogBtn').click(clearLog);
	}

	async function connectToDevice() {
		try {

			/* Check if the Web Serial API is supported */
			if (!('serial' in navigator)) {
				logMessage('Web Serial API not supported in this browser');
				return;
			}

			/* Request port with specific VID and PID filters */
			serial_port = await navigator.serial.requestPort({
				filters: [
					{
						usbVendorId: 0x2E8A,
						usbProductId: 0x000A
					}
				]
			});

			/* Open the serial port */
			await serial_port.open({ baudRate: 115200 });

			/* Get writer and reader for the serial port */
			serial_port_writer = serial_port.writable.getWriter();
			serial_port_reader = serial_port.readable.getReader();

			/* Set connection status and start status updates and continuous read */
			serial_port_connected = true;
			updateConnectionStatus(true);
			startStatusUpdates();
			startContinuousRead();

			logMessage('Connected to device');

			// Send initial status request and get firmware version
			sendCommand({ action: 'status_get' });
			sendCommand({ action: 'firmware_version_get' });
			sendCommand({ action: 'core_heating_temperature_target_get' });

		} catch (error) {
			logMessage('Connection failed: ' + error.message);
			updateConnectionStatus(false);
		}
	}

	async function disconnectFromDevice() {

		/* Skip if already disconnected */
		if (!serial_port_connected) {
			return;
		}

		try {
			if (statusUpdateInterval) {
				clearInterval(statusUpdateInterval);
				statusUpdateInterval = null;
			}

			continuousReadActive = false; // Stop continuous read loop

			if (serial_port_reader) {
				try {
					await serial_port_reader.cancel();
					await serial_port_reader.releaseLock();
				} catch (e) {
					// Reader may already be released
				}
				serial_port_reader = null;
			}

			if (serial_port_writer) {
				try {
					await serial_port_writer.releaseLock();
				} catch (e) {
					// Writer may already be released
				}
				serial_port_writer = null;
			}

			if (serial_port) {
				try {
					await serial_port.close();
				} catch (e) {
					// Port may already be closed
				}
				serial_port = null;
			}

			serial_port_connected = false;
			serial_port_reader_buffer = ''; // Clear the read buffer
			updateConnectionStatus(false);
			logMessage('Disconnected from device');

		} catch (error) {
			logMessage('Disconnect error: ' + error.message);
			// Force update UI even if cleanup fails
			serial_port_connected = false;
			updateConnectionStatus(false);
		}
	}

	function updateConnectionStatus(connected) {
		const statusDiv = $('#connectionStatus');
		const connectBtn = $('#connectBtn');
		const disconnectBtn = $('#disconnectBtn');

		if (connected) {
			statusDiv.removeClass('disconnected').addClass('connected').text('Connected');
			connectBtn.prop('disabled', true);
			disconnectBtn.prop('disabled', false);
			enableControls(true);
		} else {
			statusDiv.removeClass('connected').addClass('disconnected').text('Disconnected');
			connectBtn.prop('disabled', false);
			disconnectBtn.prop('disabled', true);
			enableControls(false);
		}
	}

	function enableControls(enabled) {
		$('#maxBtn, #lockBtn, #unlockBtn, #saveSettingsBtn, #loadSettingsBtn, #resetSettingsBtn, #loadUserInfoBtn, #saveUserInfoBtn')
			.prop('disabled', !enabled);
	}

	async function sendCommand(command) {
		if (!serial_port_connected || !serial_port_writer) {
			logMessage('Not connected to device');
			return;
		}

		try {
			const commandStr = JSON.stringify(command) + '\r\n';
			const encoder = new TextEncoder();
			await serial_port_writer.write(encoder.encode(commandStr));
			logMessage('Sent: ' + commandStr.trim());
		} catch (error) {
			logMessage('Send error: ' + error.message);
			// Check if connection was lost
			if (error.name === 'NetworkError' || error.name === 'InvalidStateError' ||
				error.message.includes('closed') || error.message.includes('disconnected')) {
				handleDisconnection('Device disconnected during send operation');
			}
		}
	}

	async function readResponse() {
		if (!serial_port_reader) return;

		try {
			const { value, done } = await serial_port_reader.read();
			if (done) {
				handleDisconnection('Device disconnected (read stream ended)');
				return;
			}

			const decoder = new TextDecoder();
			const newData = decoder.decode(value);

			// Add new data to buffer
			serial_port_reader_buffer += newData;

			// Process all complete JSON objects (separated by \r\n)
			let startIndex = 0;
			while (true) {
				const endIndex = serial_port_reader_buffer.indexOf('\r\n', startIndex);
				if (endIndex === -1) {
					// No complete line found, keep remaining data in buffer
					serial_port_reader_buffer = serial_port_reader_buffer.substring(startIndex);
					break;
				}

				const line = serial_port_reader_buffer.substring(startIndex, endIndex).trim();
				if (line) {
					logMessage('Received: ' + line);

					// Try to parse as JSON
					try {
						const data = JSON.parse(line);
						handleResponse(data);
					} catch (e) {
						// Handle non-JSON responses
						logMessage('Non-JSON response: ' + line);
					}
				}

				startIndex = endIndex + 2; // Skip \r\n
			}
		} catch (error) {
			logMessage('Read error: ' + error.message);
			// Check if connection was lost
			if (error.name === 'NetworkError' || error.name === 'InvalidStateError' ||
				error.message.includes('closed') || error.message.includes('disconnected') ||
				error.message.includes('The port has been closed')) {
				handleDisconnection('Device disconnected during read operation');
			}
		}
	}

	// Handle automatic disconnection (when device is unplugged or connection lost)
	async function handleDisconnection(reason) {
		if (!serial_port_connected) return; // Already disconnected

		logMessage('Connection lost: ' + reason);
		continuousReadActive = false; // Stop continuous read loop

		try {
			if (statusUpdateInterval) {
				clearInterval(statusUpdateInterval);
				statusUpdateInterval = null;
			}

			if (serial_port_reader) {
				try {
					await serial_port_reader.cancel();
					await serial_port_reader.releaseLock();
				} catch (e) {
					// Reader may already be released
				}
				serial_port_reader = null;
			}

			if (serial_port_writer) {
				try {
					await serial_port_writer.releaseLock();
				} catch (e) {
					// Writer may already be released
				}
				serial_port_writer = null;
			}

			if (serial_port) {
				try {
					await serial_port.close();
				} catch (e) {
					// Port may already be closed
				}
				serial_port = null;
			}

			serial_port_connected = false;
			serial_port_reader_buffer = ''; // Clear the read buffer
			updateConnectionStatus(false);
			logMessage('Disconnected from device');
		} catch (error) {
			logMessage('Error during automatic disconnect: ' + error.message);
			// Force update UI even if cleanup fails
			serial_port_connected = false;
			updateConnectionStatus(false);
		}
	}

	// Start continuous read loop to detect disconnections
	async function startContinuousRead() {
		continuousReadActive = true;

		async function readLoop() {
			while (continuousReadActive && serial_port_connected && serial_port_reader) {
				try {
					await readResponse();
					// Small delay to prevent tight loop
					await new Promise(resolve => setTimeout(resolve, 10));
				} catch (error) {
					if (continuousReadActive) {
						// Only handle if still supposed to be reading
						if (error.name === 'NetworkError' || error.name === 'InvalidStateError' ||
							error.message.includes('closed') || error.message.includes('disconnected') ||
							error.message.includes('The port has been closed')) {
							handleDisconnection('Device disconnected during read loop');
							break;
						}
					}
				}
			}
		}

		readLoop();
	}

	function handleResponse(data) {
		if (data.result === 'success') {
			if (data.status) {
				updateDeviceStatus(data.status);
			}
			if (data.settings) {
				updateSettingsDisplay(data.settings);
			}
			// Handle temperature target get response
			if (data.temperature_c !== undefined && !data.status) {
				// Could be target or measured temperature response
				// If we just requested measured temp, update current temp
				// Otherwise assume it's target temp
				const actionContext = window.lastActionContext || 'target';
				if (actionContext === 'measured') {
					$('#currentTemp').text(data.temperature_c.toFixed(1));
				} else {
					$('#targetTemp').text(data.temperature_c.toFixed(1));
					$('#tempInput').val(Math.round(data.temperature_c));
					$('#tempSlider').val(Math.round(data.temperature_c));
				}
				window.lastActionContext = null;
			}
			// Handle firmware version response
			if (data.string !== undefined) {
				logMessage('Firmware version: ' + data.string);
			}
			// Handle product information response
			if (data.number !== undefined) {
				logMessage('Product: ' + data.number + ' (Rev: ' + data.revision + ', SN: ' + data.serial + ')');
			}
			// Handle user information response
			if (data.user !== undefined) {
				if (data.user.name && Array.isArray(data.user.name)) {
					$('#userNameLine1').val(data.user.name[0] || '');
					$('#userNameLine2').val(data.user.name[1] || '');
				}
				if (data.user.icon && Array.isArray(data.user.icon)) {
					// Convert 32-byte array to 16x16 bitmap
					const iconBytes = data.user.icon.map(b => parseInt(b));
					iconPixels = bytesToBitmap(iconBytes);
					updateIconDisplay();
				}
			}
		} else if (data.result === 'failure') {
			if (data.errors && Array.isArray(data.errors)) {
				data.errors.forEach(error => logMessage('Error: ' + error));
			} else {
				logMessage('Command failed');
			}
		}
	}

	function updateDeviceStatus(status) {
		if (status.temperature && status.temperature.measured !== undefined) {
			$('#currentTemp').text(status.temperature.measured.toFixed(1));
		}
		if (status.temperature && status.temperature.target !== undefined) {
			$('#targetTemp').text(status.temperature.target.toFixed(1));
		}
		if (status.state !== undefined) {
			// Map state to heating status
			const heatingStates = ['heating', 'active'];
			$('#heatingStatus').text(heatingStates.includes(status.state) ? 'Yes' : 'No');
		}
		// Note: power level not available in current firmware status response
	}

	function updateSettingsDisplay(settings) {
		if (settings.display_brightness !== undefined) {
			$('#displayBrightness').val(settings.display_brightness);
		}
	}

	function startStatusUpdates() {
		if (statusUpdateInterval) {
			clearInterval(statusUpdateInterval);
		}

		statusUpdateInterval = setInterval(async () => {
			if (serial_port_connected) {
				await sendCommand({ action: 'status_get' });
			}
		}, 500); // Update every 500ms
	}

	async function setTemperature(temp) {
		// If no temp provided, get from input
		if (temp === undefined) {
			temp = parseFloat($('#tempInput').val());
		}
		if (temp >= 0 && temp <= 400) {
			await sendCommand({ action: 'core_heating_temperature_target_set', temperature_c: temp });
		}
	}

	async function setQuickTemp(temp) {
		$('#tempInput').val(temp);
		$('#tempSlider').val(temp);
		await sendCommand({ action: 'core_heating_temperature_target_set', temperature_c: temp });
	}

	async function saveSettings() {
		// Note: Firmware doesn't support bulk settings save
		// Individual settings need to be saved separately
		// For now, just save the target temperature which is the main setting
		const temp = parseFloat($('#tempInput').val());
		if (temp >= 0 && temp <= 400) {
			await sendCommand({ action: 'core_heating_temperature_target_set', temperature_c: temp });
			logMessage('Settings saved (target temperature only - other settings not supported by firmware)');
		}
	}

	async function loadSettings() {
		// Load current target temperature
		await sendCommand({ action: 'core_heating_temperature_target_get' });
		// Also get product information if available
		await sendCommand({ action: 'settings_product_get' });
	}

	async function resetSettings() {
		if (confirm('Reset target temperature to default (300°C)?')) {
			await sendCommand({ action: 'core_heating_temperature_target_set', temperature_c: 300 });
			$('#tempInput').val(300);
			$('#tempSlider').val(300);
		}
	}

	async function lockDevice() {
		await sendCommand({ action: 'core_heating_lock' });
	}

	async function unlockDevice() {
		await sendCommand({ action: 'core_heating_unlock' });
	}

	function logMessage(message) {
		const timestamp = new Date().toLocaleTimeString();
		$('#commLog').append(`[${timestamp}] ${message}<br/>`);
		$('#commLog').scrollTop($('#commLog')[0].scrollHeight);
	}

	function clearLog() {
		$('#commLog').empty();
	}

	// Icon Editor Functions
	function initializeIconEditor() {
		const editor = $('#iconEditor');
		editor.empty();
		for (let row = 0; row < 16; row++) {
			const rowDiv = $('<div class="icon-row"></div>');
			for (let col = 0; col < 16; col++) {
				const pixel = $('<div class="icon-pixel" data-row="' + row + '" data-col="' + col + '"></div>');

				// Mouse down - start drag
				pixel.on('mousedown', function (e) {
					e.preventDefault();
					const r = parseInt($(this).data('row'));
					const c = parseInt($(this).data('col'));
					const index = r * 16 + c;

					// Determine action based on current pixel state
					dragAction = !iconPixels[index];
					isDragging = true;

					// Set the initial pixel
					iconPixels[index] = dragAction;
					updateIconDisplay();
				});

				// Mouse enter while dragging - continue drawing
				pixel.on('mouseenter', function () {
					if (isDragging && dragAction !== null) {
						const r = parseInt($(this).data('row'));
						const c = parseInt($(this).data('col'));
						const index = r * 16 + c;
						iconPixels[index] = dragAction;
						updateIconDisplay();
					}
				});

				rowDiv.append(pixel);
			}
			editor.append(rowDiv);
		}

		// Stop dragging when mouse leaves the editor or mouse is released
		editor.on('mouseleave', function () {
			isDragging = false;
			dragAction = null;
		});

		// Stop dragging on mouse up anywhere
		$(document).on('mouseup', function () {
			isDragging = false;
			dragAction = null;
		});

		updateIconDisplay();
	}

	function updateIconDisplay() {
		$('.icon-pixel').each(function () {
			const row = parseInt($(this).data('row'));
			const col = parseInt($(this).data('col'));
			const index = row * 16 + col;
			if (iconPixels[index]) {
				$(this).addClass('black');
			} else {
				$(this).removeClass('black');
			}
		});
	}

	function clearIcon() {
		iconPixels.fill(false);
		updateIconDisplay();
	}

	function invertIcon() {
		for (let i = 0; i < iconPixels.length; i++) {
			iconPixels[i] = !iconPixels[i];
		}
		updateIconDisplay();
	}

	// Convert 32-byte array to 16x16 bitmap (bits)
	function bytesToBitmap(bytes) {
		const pixels = Array(16 * 16).fill(false);
		for (let i = 0; i < 32; i++) {
			const byte = bytes[i] || 0;
			for (let bit = 0; bit < 8; bit++) {
				const pixelIndex = i * 8 + bit;
				if (pixelIndex < 256) {
					pixels[pixelIndex] = (byte & (1 << (7 - bit))) !== 0;
				}
			}
		}
		return pixels;
	}

	// Convert 16x16 bitmap (bits) to 32-byte array
	function bitmapToBytes(pixels) {
		const bytes = Array(32).fill(0);
		for (let i = 0; i < 32; i++) {
			let byte = 0;
			for (let bit = 0; bit < 8; bit++) {
				const pixelIndex = i * 8 + bit;
				if (pixelIndex < 256 && pixels[pixelIndex]) {
					byte |= (1 << (7 - bit));
				}
			}
			bytes[i] = byte;
		}
		return bytes;
	}

	async function loadUserInfo() {
		await sendCommand({ action: 'settings_user_get' });
	}

	async function saveUserInfo() {
		const line1 = $('#userNameLine1').val().trim();
		const line2 = $('#userNameLine2').val().trim();

		// Validate name lengths
		if (line1.length === 0 || line2.length === 0) {
			logMessage('Error: Both name lines must have at least 1 character');
			return;
		}
		if (line1.length > 12 || line2.length > 12) {
			logMessage('Error: Name lines must be 12 characters or less');
			return;
		}

		// Convert icon bitmap to byte array
		const iconBytes = bitmapToBytes(iconPixels);

		// Send command
		await sendCommand({
			action: 'settings_user_set',
			icon: iconBytes,
			name: [line1, line2]
		});
	}

	// Handle image loading and conversion to icon
	async function handleImageLoad(event) {
		const file = event.target.files[0];
		if (!file) {
			logMessage('No file selected');
			return;
		}

		logMessage('Loading image: ' + file.name);

		try {
			// Load image
			const image = await loadImageFromFile(file);
			logMessage('Image loaded, processing...');

			// Process image: resize to 16x16 and convert to black/white with threshold 128
			const pixels = processImageToBitmap(image, 128);

			// Update icon editor
			iconPixels = pixels;
			updateIconDisplay();

			logMessage('Image converted to icon successfully');

		} catch (error) {
			logMessage('Error loading image: ' + error.message);
			console.error('Image loading error:', error);
		}

		// Clear file input so same file can be selected again
		event.target.value = '';
	}

	// Load image from file
	function loadImageFromFile(file) {
		return new Promise((resolve, reject) => {
			const reader = new FileReader();
			reader.onload = function (e) {
				const img = new Image();
				img.onload = () => resolve(img);
				img.onerror = () => reject(new Error('Failed to load image'));
				img.src = e.target.result;
			};
			reader.onerror = () => reject(new Error('Failed to read file'));
			reader.readAsDataURL(file);
		});
	}

	// Process image: resize to 16x16 and convert to black/white bitmap
	function processImageToBitmap(image, threshold) {
		try {
			// Create a canvas for resizing and processing
			const canvas = document.createElement('canvas');
			canvas.width = 16;
			canvas.height = 16;
			const ctx = canvas.getContext('2d');

			// Fill with white background first (handles transparent PNGs)
			ctx.fillStyle = '#FFFFFF';
			ctx.fillRect(0, 0, 16, 16);

			// Use image smoothing for better quality when resizing
			ctx.imageSmoothingEnabled = true;
			ctx.imageSmoothingQuality = 'high';

			// Draw image to canvas (resize to 16x16)
			// This will composite transparent areas onto the white background
			ctx.drawImage(image, 0, 0, 16, 16);

			// Get image data
			const imageData = ctx.getImageData(0, 0, 16, 16);
			const data = imageData.data;

			// Convert to bitmap (black/white based on threshold)
			const pixels = [];
			for (let i = 0; i < data.length; i += 4) {
				// Get RGBA values
				const r = data[i];
				const g = data[i + 1];
				const b = data[i + 2];
				const a = data[i + 3]; // alpha channel

				// If pixel is transparent or very transparent, make it white
				if (a < 128) {
					pixels.push(false); // white
					continue;
				}

				// Convert RGB to grayscale using standard weights
				const gray = Math.round(0.299 * r + 0.587 * g + 0.114 * b);

				// Apply threshold: if grayscale value is below threshold, make it black (true), otherwise white (false)
				pixels.push(gray < threshold);
			}

			return pixels;
		} catch (error) {
			console.error('Error processing image:', error);
			throw new Error('Failed to process image: ' + error.message);
		}
	}
</script>